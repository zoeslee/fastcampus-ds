# -*- coding: utf-8 -*-
"""상품리스트 분석

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bGPFLlE8DIQA-KT5_L_-C8FNQPu7GPbW
"""

import pandas as pd
import numpy as np

from google.colab import drive
drive.mount('/content/drive')

# 상품등록 파일 불러오기
product_reg_raw = pd.read_excel('')

"""# 첫행 변경 및 필요한 컬럼 불러오기"""

# 읽어온 데이터의 컬럼명 출력
print(product_reg_raw.columns)

# df에 할당된 데이터의 행렬 사이즈 출력
print(product_reg_raw.shape)

# 상위 5개 데이터 확인
product_reg_raw.head(3)

df = pd.DataFrame.copy(product_reg_raw)
df.head()

df.columns = df.iloc[0]

df.head()

df = df.iloc[1:]
df.head(5)

print(df.columns)

# 상품등록_화면 엑셀 불러오기
df2_raw = pd.read_excel('/content/drive/My Drive/dataset/20200920135214_상품등록_화면.xlsx')

# 읽어온 데이터의 컬럼명 출력
print(df2_raw.columns)

# df에 할당된 데이터의 행렬 사이즈 출력
print(df2_raw.shape)

# 상위 5개 데이터 확인
df2_raw.head(3)

df2 = pd.DataFrame.copy(df2_raw)
df2.head(3)

new_col = ['상품코드', '품목명', '국가', '와이너리', '상품명', '빈티지', '용량', '와인종류', '등급', '지역', '세부지역', '밭이름', '점수', '포도품종','판매구분']
df2 = df2[new_col]
print(df2.shape)
df2.head(3)

df2.info()

df2.head(5)

"""# Feature Description
- 상품코드 (index) : 품목별 빈티지별 용량별 생성된 코드입니다.
- 품목명 (product) : 와이너리명 품목명 빈티지명과 함께 하프보틀이나 매그넘 등 별도 사이즈를 표기한 품목명입니다.
- 국가 (country) : 품목이 생산된 국가입니다.
- 와이너리 (winery) : 품목을 생산한 와이너리 명칭입니다. 유한회사, 주식회사등의 표기는 생략하였습니다.
- 상품명 (product_name) : 와이너리명을 제외한 상품명입니다. 와이너리가 달라도 상품명에 지역을 사용하는 경우가 있어 중복될 수 있습니다. 
- 빈티지 (vintage) : 와인을 생산하기 위한 포도를 수확한 해를 빈티지라고 부르며, 빈티지를 와인에 표기합니다. 해당 값은 각 와인에 명시되어있는 값을 따릅니다. 
- 용량 (volume) : 와인의 용량을 표기합니다. 가장 일반적인 750ml 외에 375ml, 1500ml부터 9000ml까지 나뉘어 있습니다.
- 와인종류 (type) : 레드,화이트, 스파클링, 로제, 스위트 등 와인의 종류를 구분합니다.
- 등급 (class) : 기본적으로 프랑스 및 기타 구대륙의 등급을 표기합니다. 미국의 AVA의 경우 등급과는 다른점이 있어 따로 명시하지 않습니다. (업데이트 필요)
- 지역 (region) : 와인 생산지를 기재함에 있어 국가 다음으로 큰 범주입니다. 
- 세부지역 (subregion) : 지역 하위에 존재하는 세부지역입니다.
- 밭이름 (appellation) : 프랑스 부르고뉴에서 밭을 표기하는 Appellation이 있을 경우 명시합니다.
- 점수 (accolade) : Robert Parker, Wine Spectator, Burghound 세 매거진을 참조하여 기재합니다. (업데이트 필요)
- 포도품종 (variety) : 품목별로 와인을 생산하기 위해 사용된 품종들을 명시합니다. 샴페인의 경우 각 품목별 블렌딩 비율을 기재하며, 나머지 품목의 경우 주품종이 80% 이상 사용되었을 경우 주품종만 표기, 흔하지 않은 품종이 사용되었을 경우 전체 표기합니다. (업데이트 필요)
- 판매구분 (status) : 판매구분에 따른 분류입니다.

# 국가별 지역별 세부산지별 품목 개수 확인
- NaN값 일단 드랍하고 데이터 있는 행들만 분석
"""

df3 = df2[['국가', '와이너리', '상품명', '와인종류', '등급', '지역', '세부지역', '포도품종']]
print(df3.shape)
df3.head(10)

df3.loc[df3['등급'].isna()] # 데이터 내 등급이 NaN인 값 확인, 행 중에 품목명이 NaN값인 것들은 드랍하는게 나음.

df3.info() # 각 열에 NaN값이 몇개씩 있는지 대략적으로 알 수 있다.

df3.loc[df3['와이너리'].notnull()]

pd.DataFrame.drop_duplicates(df3)
print(df3.shape)

df3.head(20)

df3.groupby('국가').count()

pd.set_option('max_rows', 500) # pandas에서 보여줄 수 있는 행의 숫자 제한을 최대 500개로 지정
pd.set_option('min_rows', 100) # pandas에서 보여줄 수 있는 행의 숫자 제한을 최소 100개로 지정

df3.groupby(['국가','지역','세부지역']).count()



"""# 대표품목 생성 (빈티지 및 용량표기 제거)"""

df2.info()

df4 = df2[['품목명', '와이너리','상품명','포도품종','판매구분']]

df4.info()

# pd.set_option('display.max_rows',df4.shape[0]+1)
pd.set_option('display.max_rows',10)
df4 = df4.loc[(df4['상품명'].notnull()) & (df4['포도품종'].notnull()) & (df4['와이너리'].notnull())]
df4

df4['대표품목명'] = df4['와이너리'] + " " + df4['상품명']

df4.head(10)

df4 = df4[['대표품목명', '포도품종','판매구분']]

pd.set_option('display.max_rows',10)
df4.drop_duplicates(keep='last')

df4.loc[df4['대표품목명'].str.contains('ml')]

df4['대표품목명'] = df4['대표품목명'].str.strip(' 1500ml')

df4.head()

df4['대표품목명'] = df4['대표품목명'].str.strip(" 375ml")
df4['대표품목명'] = df4['대표품목명'].str.strip(" 3000ml")

df4.loc[df4['대표품목명'].str.contains('ml')]

"""# 포도품종 개수 시각화"""

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm -/.cache/matplotlib -rf

# matplotlib 불러오기
import matplotlib.pyplot as plt
plt.rc('font', family='NanumBarunGothic')

df4.head()

df4 = df4.loc[(df4['판매구분'] == 'ASK') | (df4['판매구분'] == '판매')]
df4.info()

grouped = df4.groupby('포도품종').count()

grouped.sort_values('대표품목명', ascending=False)

df4.loc[df4['포도품종'] == 'PM 90%, PN 7%,\nCH 3%']

